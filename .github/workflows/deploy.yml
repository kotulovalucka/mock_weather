name: Deploy to EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: self-hosted
    environment: production

    steps:
      - name: Clean workspace
        run: |
          # Ensure the runner has permissions to clean the workspace
          sudo chown -R $USER:$USER .
          # Force remove problem directories
          sudo rm -rf ./* || true
          sudo rm -rf ./.* || true

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          clean: false  # Disable automatic cleaning
          fetch-depth: 1

      - name: Set permissions
        run: |
          # Set proper ownership and permissions after checkout
          sudo chown -R $USER:$USER .
          chmod -R 755 .
          
          # Ensure logs directory exists with proper permissions
          mkdir -p logs/app
          chmod -R 777 logs

      - name: Create .dockerenv file
        run: |
          echo "${{ secrets.PROD_ENV_FILE }}" > .dockerenv
          chmod 644 .dockerenv

      - name: Load environment variables
        run: |
          set -a
          source .dockerenv
          set +a
          
          # Store variables for subsequent steps
          echo "DB_USER=$DB_USER" >> $GITHUB_ENV
          echo "DB_PASSWORD=$DB_PASSWORD" >> $GITHUB_ENV
          echo "DB_NAME=$DB_NAME" >> $GITHUB_ENV

      - name: Build and start services
        run: |
          # Ensure Docker has right permissions
          sudo chown -R $USER:$USER /var/run/docker.sock || true
          
          # Load env variables
          set -a
          source .dockerenv
          set +a
          
          # Stop any running containers
          docker-compose down --remove-orphans || true
          
          # Remove old images
          docker image prune -f
          
          # Build and start services
          docker-compose build --no-cache
          docker-compose up -d
          
          # Show running containers
          docker-compose ps

      - name: Health check
        run: |
          export DB_USER=${{ env.DB_USER }}
          export DB_NAME=${{ env.DB_NAME }}
          
          # Wait for PostgreSQL
          timeout=300
          until docker-compose exec -T postgres pg_isready -U "$DB_USER" -d "$DB_NAME" || [ $timeout -eq 0 ]; do
            echo "Waiting for PostgreSQL..."
            sleep 5
            ((timeout--))
          done
          
          if [ $timeout -eq 0 ]; then
            echo "PostgreSQL failed to become ready"
            docker-compose logs postgres
            exit 1
          fi
          
          # Check API
          timeout=60
          until curl -f http://localhost:3000/api/v1/health/status || [ $timeout -eq 0 ]; do
            echo "Waiting for API..."
            sleep 5
            ((timeout--))
          done

      - name: Show logs on completion
        if: always()
        run: docker-compose logs || true
